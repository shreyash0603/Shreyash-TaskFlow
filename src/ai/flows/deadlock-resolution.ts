// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview AI-powered deadlock resolution suggestions for TaskFlow.
 *
 * - resolveDeadlock - A function that suggests strategies to resolve deadlocks by re-evaluating task execution.
 * - ResolveDeadlockInput - The input type for the resolveDeadlock function.
 * - ResolveDeadlockOutput - The return type for the resolveDeadlock function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const ResolveDeadlockInputSchema = z.object({
  taskDependencies: z
    .record(z.array(z.string()))
    .describe(
      'A map of tasks to their dependencies. The keys are task IDs, and the values are arrays of task IDs representing dependencies.'
    ),
  failedTasks: z
    .array(z.string())
    .describe('An array of task IDs that have failed.'),
  runningTasks: z
    .array(z.string())
    .describe('An array of task IDs that are currently running.'),
  completedTasks: z
    .array(z.string())
    .describe('An array of task IDs that have completed successfully.'),
  resourceUsage: z
    .record(z.number())
    .describe(
      'A map of task IDs to their resource usage, expressed as a numerical value.'
    ),
  pastExecutionData: z
    .string()
    .describe(
      'A string containing data from past task executions, including success and failure rates.'
    ),
});

export type ResolveDeadlockInput = z.infer<typeof ResolveDeadlockInputSchema>;

const ResolveDeadlockOutputSchema = z.object({
  suggestedStrategies: z
    .array(z.string())
    .describe(
      'An array of strategies to resolve the deadlock, such as adjusting task priorities or suggesting alternative execution paths.'
    ),
  reevaluatedTaskExecutionOrder: z
    .array(z.string())
    .describe(
      'An array of task IDs representing a re-evaluated execution order to break the deadlock.'
    ),
  explanation: z
    .string()
    .describe(
      'A detailed explanation of the suggested strategies and the re-evaluated task execution order.'
    ),
});

export type ResolveDeadlockOutput = z.infer<typeof ResolveDeadlockOutputSchema>;

export async function resolveDeadlock(input: ResolveDeadlockInput): Promise<ResolveDeadlockOutput> {
  return resolveDeadlockFlow(input);
}

const prompt = ai.definePrompt({
  name: 'resolveDeadlockPrompt',
  input: {schema: ResolveDeadlockInputSchema},
  output: {schema: ResolveDeadlockOutputSchema},
  prompt: `You are an AI-powered task flow deadlock resolution expert.

You are provided with the following information about the current task flow:

- Task Dependencies: {{{JSON.stringify(taskDependencies, null, 2)}}}
- Failed Tasks: {{{JSON.stringify(failedTasks, null, 2)}}}
- Running Tasks: {{{JSON.stringify(runningTasks, null, 2)}}}
- Completed Tasks: {{{JSON.stringify(completedTasks, null, 2)}}}
- Resource Usage: {{{JSON.stringify(resourceUsage, null, 2)}}}
- Past Execution Data: {{{pastExecutionData}}}

Based on this information, suggest strategies to resolve the deadlock, such as adjusting task priorities or suggesting alternative execution paths. Provide a re-evaluated task execution order to break the deadlock, and a detailed explanation of your suggestions.

Output should be a JSON object with the following keys:
- suggestedStrategies: An array of strategies to resolve the deadlock.
- reevaluatedTaskExecutionOrder: An array of task IDs representing a re-evaluated execution order.
- explanation: A detailed explanation of the suggested strategies and the re-evaluated task execution order.`,
});

const resolveDeadlockFlow = ai.defineFlow(
  {
    name: 'resolveDeadlockFlow',
    inputSchema: ResolveDeadlockInputSchema,
    outputSchema: ResolveDeadlockOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);
